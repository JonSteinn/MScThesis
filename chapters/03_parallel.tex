\coverchapter{Parallel specifications}\label{ch:parallel}
The concept of parallelism\footnote{Not to be confused with the programming paradigm.} in specifications is a binary relation over $\specset \times \specset$ where $\specset$ is the set of all specifications. The purpose of parallelism is to structurally match specifications with the aim of constructing a bijection between them. In order to define this relation  we will need to formalize some notation and define supporting concepts.

A combinatorial class that is empty or contains a single element of size less than 2 is called a \emph{terminal class}. Let
\begin{align*}
    \sclsi{C}{1} &\cong \sclsi{C}{11} \circ_1 \sclsi{C}{12} \circ_1 \dotsm \circ_1 \sclsi{C}{1n_1}\\
    \sclsi{C}{2} &\cong \sclsi{C}{21} \circ_2 \sclsi{C}{22} \circ_2 \dotsm \circ_2 \sclsi{C}{2n_2}\\
    &\hspace{0.25cm}\vdots\\
    \sclsi{C}{k} &\cong \sclsi{C}{k1} \circ_k \sclsi{C}{k2} \circ_k \dotsm \circ_k \sclsi{C}{kn_k}\\
\end{align*}
be the rules of a specification $\spec{C}$ for a class $\sclsi{C}{1}$ where $\circ_1,\circ_2,\dotsc,\circ_k$ are constructors and each $\sclsi{C}{ij}$ is a terminal class or in $\set{\sclsi{C}{1}, \sclsi{C}{2}, \dotsc, \sclsi{C}{k}}$ for
\[
    (i,j) \in \mathscr{D}(\spec{C}) = \cset{(a,b)}{a \in [k], b \in [n_a]}.
\]
For any $i\in[k]$ where $n_i=1$ the constructor $o_i$ is a unary operator and in the case of equivalence rules, $\sclsi{C}{i} \cong \sclsi{C}{i1}$, the constructor $\circ_i$ is an identity unary operator $\mathbf{1}^\circ$. To describe this specification we will use the notation 
\[
    \spec{C} = (L,O,R,D) = 
    \left(
    \begin{pmatrix}
        \sclsi{C}{1}\\ \sclsi{C}{2}\\ \vdots\\ \sclsi{C}{k}
    \end{pmatrix}
    \begin{matrix}\\ \\ \\,\end{matrix}
    \begin{pmatrix}
        \circ_1\\\circ_2\\\vdots\\\circ_k
    \end{pmatrix}
    \begin{matrix}\\ \\ \\,\end{matrix}
    \begin{pmatrix}
    R_{11} & R_{12} & \dotsm & R_{1t} \\
    R_{21} & R_{22} & \dotsm & R_{2t} \\
    \vdots & \vdots & \ddots & \vdots \\
    R_{k1} & R_{k2} & \dotsm & R_{kt}
    \end{pmatrix}
    \begin{matrix}\\ \\ \\,\end{matrix}
    \begin{pmatrix}
        n_1\\n_2\\\vdots\\n_k
    \end{pmatrix}
    \right)
\]
where $t = \max\set{n_1,n_2,\dotsc,n_k}$, $R_{ij} = \sclsi{C}{ij}$ for $(i,j) \in \mathscr{D}(\spec{C})$ and the remaining entries of $R$ are the empty set (and of no importance). If we revisit the specification for $\Av{132}$ from \SectionRef{sec:tilings} with this notation we have 
\[
    \spec{C} = \left(
    \begin{pmatrix}\Av{132}\\\textsf{Av}_{\geq1}(132)\end{pmatrix}
    \begin{matrix}\\,\end{matrix}
    \begin{pmatrix}\sqcup\\ \times\end{pmatrix}
    \begin{matrix}\\,\end{matrix}
    \begin{pmatrix}
    \set{\varepsilon} & \textsf{Av}_{\geq1}(132) & \emptyset \\
    \Av{132} & \set{\point{0.1}} & \Av{132}
    \end{pmatrix}
    \begin{matrix}\\,\end{matrix}
    \begin{pmatrix}2\\3\end{pmatrix}
    \right)\begin{matrix}\\.\end{matrix}
\]

\section{Specification graphs}
\begin{definition}
Let $\spec{C} = \left(L, O, R, D\right)$ be a specification with $k$ rules. The \emph{specification graph} of $\spec{C}$ is the rooted directed multigraph $\specg{C} = (V,E,r,\src,\dst,\op)$ with vertices 
\[
    V = \bigcup_{i=1}^k\set{L_i,R_{i1},R_{i2},\dotsc,R_{iD_i}},
\]
labelled edges
\[
    E = \left[\sum_{i=1}^kD_i\right],
\]
a root $r = L_1$ and mappings from edge labels to their sources, destinations and constructors, 
\[
    (\src(e), \dst(e), \op(e)) = \left(L_{\alpha(e)},R_{\alpha(e)\beta(e)},O_{\alpha(e)}\right)
\]
with
\[
    \alpha(e) = \min\cset{i \in [k]}{D_1 + D_2 + \dotsm + D_k \geq e}
\]
and
\[
    \beta(e) = e-\sum_{i=1}^{\alpha(e) - 1}D_i.
\]
\end{definition}

The edge labels are defined to share order with the lexicographical order of $\mathscr{D}(\spec{C})$. That is, edge $i$ will have a destination $R_{jk}$  where $(j,k)$ is the $i^\text{th}$ largest entry in $\mathscr{D}(\spec{C})$. The source and constructor for said edge would be the corresponding class in $L$ and constructor in $O$. An example for the aforementioned specification for $\Av{132}$ can be seen in \FigureRef{fig:specgraph132}. The destinations of labels are
\[
    \begin{pmatrix}
        \dst(1) & \dst(2) & \emptyset\\
        \dst(3) & \dst(4) & \dst(5)
    \end{pmatrix}
    =
    \begin{pmatrix}
    \set{\varepsilon} & \textsf{Av}_{\geq1}(132) & \emptyset \\
    \Av{132} & \set{\point{0.1}} & \Av{132}
    \end{pmatrix}
    \begin{matrix}\\.\end{matrix}
\]

\begin{figure}[ht!]
    \centering
    \input{graphics/spec_graph_132}
    \caption{The specification graph for a specification for $\Av{132}$.}
    \label{fig:specgraph132}
\end{figure}

A path in a rooted multigraph can be described as a sequence of edges\footnote{Using a sequence of vertices is ambiguous in multigraphs.}. A rooted path is any such sequence that starts with an edge from the root. There is also an empty rooted path, $\varepsilon$, corresponding to going nowhere from the root. For a finite rooted path $p=e_1e_2\dotsm e_n$, of length $|p|=n$, in a specification graph we define $\textsf{tail}(p)$ as $\dst(e_n)$ if $n>0$ and the root otherwise and refer to it as the \emph{tail} of $p$. Define $\oplus$ as the operator that concatenates two paths (or edges), that is
\[
    \alpha_1\alpha_2 \dotsm \alpha_n \oplus \beta_1\beta_2 \dotsm \beta_k = \alpha_1\alpha_2 \dotsm \alpha_n\beta_1\beta_2 \dotsm \beta_k.
\]

\begin{definition}
Let $(V,E,r,\src,\dst,\op)$ be a specification graph. Given a finite rooted path $p \in E^m$, its \emph{path expansion} is the set 
\[
    p^\oplus = \cset{p \oplus e'}{e' \in E, \ \dst(e') \neq \emptyset \text{ and } \src(e') = \textsf{tail}(p)}.
\]
\end{definition}
If a path ends in a terminal class, its path expansion is the empty set. Note that we never expand to empty classes and that expansions only depend on the tail of the path. In the graph from \FigureRef{fig:specgraph132} we have $\varepsilon^+ = \set{1,2}$, $2^+ = \set{23,24,25}$, $24^+ = \emptyset$ and $2523^+ = \set{25231, 25232}$.


\begin{definition}
A \emph{specification path} in a specification graph $(V,E,r,\src,\dst,\op)$ is a finite rooted path $p=e_1e_2\dotsm e_m \in E^m$ in said graph such that $\textsf{tail}(p)$ is a terminal class or there exists a $j\in[m]$ such that $\src(e_j) = \textsf{tail}(p)$.
\end{definition}
The paths $1$, $24$, $23$, $25$, $23232$, $232323$ and $252324$ are examples of specification paths in the specification graph in \FigureRef{fig:specgraph132}. In fact, all finite rooted paths in the graph except the paths $\varepsilon$ and $2$ are specification paths. We will use the notation $e_1^{\op(e_1)}e_2^{\op(e_2)}\dotsm e_m^{\op(e_m)}$ interchangeably with the one without the constructors, often opting for the inclusion of constructors when their relevance is of importance. 

Let $\spec{C}$ be a specification and $p=e_1e_2\dotsm e_m \in E^m$ be a specification path in $\mathfrak{G}\left(\spec{C}\right) = (V,E,r,\src, \dst, \op)$. The \emph{nonequivalent steps} of $p$, denoted $p^\ast$, is the set of edge indices of edges in $p$ that do not correspond to a equivalence rule, that is $p^\ast = \cset{i\in[m]}{\op(e_i) \neq \mathbf{1}^\circ}$. Suppose we have a specification  
\[
    \spec{C} = \left(\begin{pmatrix}A\\B\\C\\D\end{pmatrix}\begin{matrix}\\\\\\,\end{matrix} \begin{pmatrix}\sqcup\\ \mathbf{1}^\circ\\ \times\\ \mathbf{1}^\circ\end{pmatrix}\begin{matrix}\\\\\\,\end{matrix}\begin{pmatrix} \set{\varepsilon} & B \\ C & \emptyset \\ \set{c} & D \\ A & \emptyset\end{pmatrix}\begin{matrix}\\\\\\,\end{matrix}\begin{pmatrix}2\\1\\2\\1\end{pmatrix}\right)
\]
where $c$ is an atom. For the specification path $p = 2356235$ in $\mathfrak{G}\left(\spec{C}\right)$ the nonequivalent steps are $p^\ast = \set{1,3,5,7}$. The specification graph for $\spec{C}$, as well as the path $p$ where the nonequivalent steps are solid can be seen in \FigureRef{fig:noneqsteps}. 
\begin{figure}[ht!]
    \centering
    \input{graphics/noneq_steps}
    \caption{A specification graph on the left and a specification path from the graph, $e_1e_2\dotsm e_7=2356235$, on the right with nonequivalent steps, $\set{1,3,5,7}$, as solid arrows.}
    \label{fig:noneqsteps}
\end{figure}

Given a path $p = e_1e_2\dotsm e_n$ in a specification graph $(V,E,r,\src,\dst,\op)$ we define
\[
     \textsf{lstrip}(p) = \begin{cases} \textsf{lstrip}(e_2e_3\dotsm e_n) & \text{ if } n > 0 \text{ and } \op(e_1) = \mathbf{1}^\circ,\\
     p & \text{ otherwise}
     \end{cases}
\]
and
\[
    \textsf{rextend}(p) = \begin{cases}
        \textsf{rextend}(q) & \text{ if } p^+ = \set{q} \text{ and } \textsf{tail}(p) \cong \textsf{tail}(q),\\
        p & \text{ otherwise}.
    \end{cases}
\]
In the graph from \FigureRef{fig:noneqsteps} we have $\textsf{lstrip}(356) = 56$ and $\textsf{rextend}(35) = 356$.

\section{Parallel specifications}
\begin{definition}
Two constructors $\circ_1$ and $\circ_2$ are equivalent, $\circ_1 \equiv \circ_2$, if
\[
    \sclsi{C}{1} \circ_1 \sclsi{C}{2} \circ_1 \dotsm \circ_1 \sclsi{C}{n} \cong \sclsi{D}{1} \circ_2 \sclsi{D}{2} \circ_2 \dotsm \circ_2 \sclsi{D}{n}
\]
are isomorphic for all classes $\sclsi{C}{1},\sclsi{C}{2},\dotsc,\sclsi{C}{n}$ and $\sclsi{D}{1},\sclsi{D}{2},\dotsc,\sclsi{D}{n}$ in the domain of $\circ_1$ and $\circ_2$ respectively, where $\sclsi{C}{i}\cong\sclsi{D}{i}$ for $i \in [n]$\footnote{For our purposes it would suffice to restrict the domains to classes of specifications.}.
\end{definition}

Before defining \emph{parallel specification paths} formally, we will give a brief informal description. Two specification paths in two different specifications are parallel if they have equivalent constructors at every step and end in either isomorphic terminal classes or a recursion at an equal distance, ignoring equivalence steps.

\begin{definition}
Let $\spec{C}$ and $\spec{D}$ be two specifications with specification graphs 
\[
\specg{C}=(V_1,E_1,r_1,\src_1,\dst_1,\op_1) \text{ and } \specg{D} = (V_2,E_2,r_2,\src_2,\dst_2,\op_2).
\]
Let $\alpha=\alpha_1\alpha_2 \dotsm \alpha_n$ be a specification path in $\mathfrak{G}\left(\spec{C}\right)$ and $\beta=\beta_1\beta_2 \dotsm \beta_k$ in $\mathfrak{G}\left(\spec{D}\right)$. We say that $\alpha$ and $\beta$ are \emph{parallel specification paths} if all of the following conditions are met.
\begin{enumerate}[i.]
    \item The length, ignoring equivalences, is the same, that is $|\alpha^\ast| = |\beta^\ast| = s$.
    \item For all $q\in[s]$ we have $\op_1(\alpha_{i_q}) \equiv \op_2(\beta_{j_q})$ where $\sort(\alpha^\ast) = (i_1,i_2,\dotsc,i_s)$ and $\sort(\beta^\ast) = (j_1,j_2,\dotsc,j_s)$.
    \item Either $\dst_1(\alpha_n)$ and $\dst_2(\beta_n)$ are isomorphic terminal classes or there exists a $(i,j) \in [n] \times [k]$ such that $\src_1(\alpha_i) = \dst_1(\alpha_n)$, $\src_2(\beta_j) = \dst_2(\beta_k)$ and
    \[
        |\cset{\ell \in \alpha^\ast}{i \leq \ell \leq n}| = |\cset{\ell \in \beta^\ast}{j \leq \ell \leq k}|.
    \]
\end{enumerate}
\end{definition}
We write $\alpha \parallel \beta$ to indicate that specification paths $\alpha$ and $\beta$ are parallel and $\alpha \nparallel \beta$ to indicate that they are not. Suppose we have specifications
\[
    \spec{C} = \left(
        \begin{pmatrix}
            A\\
            B
        \end{pmatrix}
        \begin{matrix}\\,\end{matrix}
        \begin{pmatrix}
            \sqcup\\
            \times
        \end{pmatrix}
        \begin{matrix}\\,\end{matrix}
        \begin{pmatrix}
            \set{\varepsilon} & B\\
            \set{c} & A
        \end{pmatrix}
        \begin{matrix}\\,\end{matrix}
        \begin{pmatrix}
            2\\
            2
        \end{pmatrix}
    \right)
\]
and
\[
    \spec{D} = \left(
        \begin{pmatrix}
            E\\
            F\\
            G\\
            H\\
            I\\
            J
        \end{pmatrix}
        \begin{matrix}\\\\\\\\\\,\end{matrix}
        \begin{pmatrix}
            \sqcup\\
            \sqcup\\
            \mathbf{1}^\circ\\
            \times\\
            \sqcup\\
            \times
        \end{pmatrix}
        \begin{matrix}\\\\\\\\\\,\end{matrix}
        \begin{pmatrix}
            F & G\\
            \set{\varepsilon} & E\\
            H & \emptyset\\
            \set{d} & I\\
            \set{\varepsilon} & J\\
            \set{d} & I
        \end{pmatrix}
        \begin{matrix}\\\\\\\\\\,\end{matrix}
        \begin{pmatrix}
            2\\
            2\\
            1\\
            2\\
            2\\
            2
        \end{pmatrix}
    \right)
\]
where $c$ and $d$ are atoms. For the specification graphs $\mathfrak{G}\left(\spec{C}\right)$ and $\mathfrak{G}\left(\spec{D}\right)$ in \FigureRef{fig:para_path}, we have $2^\sqcup4^\times2^\sqcup4^\times \parallel 2^\sqcup5^{\mathbf{1}^\circ}7^\times9^\sqcup11^\times$ and $2^\sqcup4^\times1^\sqcup \nparallel 1^\sqcup$.
\begin{figure}[ht!]
    \centering
    \input{graphics/para_path}
    \caption{The paths $2^\sqcup4^\times2^\sqcup4^\times$ in the left graph and $2^\sqcup5^{\mathbf{1}^\circ}7^\times9^\sqcup11^\times$ in the right graph are parallel specification paths.}
    \label{fig:para_path}
\end{figure}

Before defining parallelism in specifications, we introduce the idea informally and provide a supporting definition. The relation is satisfied if, recursively, every path pair is either parallel or we can pair the expansions of both such that each pair is parallel, starting from the empty rooted paths and ignoring equivalences.

Let $\mathfrak{G}(\spec{C})$ and $\mathfrak{G}(\spec{D})$ be two specification graphs. The rooted paths $\alpha$ in $\mathfrak{G}(\spec{C})$ and $\beta$ in $\mathfrak{G}(\spec{D})$ are said to be \emph{matchable} if $\textsf{rextend}(\alpha) \parallel \textsf{rextend}(\beta)$ or if there exists a bijection $\phi: \textsf{rextend}(\alpha)^+ \mapsto \textsf{rextend}(\beta)^+$ such that $a$ and $\phi(a)$ are matchable for all $a\in \textsf{rextend}(\alpha)^+$.

\begin{definition}\label{def:parspec}
Two specifications $\spec{C}$ and $\spec{D}$ are \emph{parallel} if the empty rooted paths in their respective specification graphs are matchable.
\end{definition}

We use $\spec{C} \parallel \spec{D}$ and $\spec{C} \nparallel \spec{D}$ do indicate that specifications are or are not parallel. Take for example the specifications
\[
    \spec{C} = \left(
    \begin{pmatrix}
        A\\B    
    \end{pmatrix}
    \begin{matrix}\\,\end{matrix}
    \begin{pmatrix}
        \sqcup\\
        \times
    \end{pmatrix}
    \begin{matrix}\\,\end{matrix}
    \begin{pmatrix}
        \set{\varepsilon} & B & \emptyset\\
        \set{c} & A & A
    \end{pmatrix}
    \begin{matrix}\\,\end{matrix}
    \begin{pmatrix}
        2\\3
    \end{pmatrix}
    \right)
\]
and
\[
    \mathcal{D} = \left(
        \begin{pmatrix}
            E\\F\\G\\H
        \end{pmatrix}
        \begin{matrix}\\\\\\,\end{matrix}
        \begin{pmatrix}
            \sqcup\\\times\\\mathbf{1}^\circ\\\sqcup
        \end{pmatrix}
        \begin{matrix}\\\\\\,\end{matrix}
        \begin{pmatrix}
            F & \set{\varepsilon} & \emptyset\\
            G & \set{d} & E\\
            H & \emptyset & \emptyset\\
            \set{\varepsilon} & F & \emptyset
        \end{pmatrix}
        \begin{matrix}\\\\\\,\end{matrix}
        \begin{pmatrix}
            2\\3\\1\\2
        \end{pmatrix}
    \right)
\]
where $c$ and $d$ are atoms. These specifications are parallel as can be seen in \FigureRef{fig:para_spec} which includes specification graphs for both along with the recursion tree for their empty rooted paths.
\begin{figure}[ht!]
    \centering
    \input{graphics/para_spec}
    \vspace{0.7cm}
    \input{graphics/recursion_tree}
    \caption{The specification graphs of two parallel specifications and the matchable recursion tree starting from their empty rooted paths.}
    \label{fig:para_spec}
\end{figure}

The parallel relation is reflexive and symmetric for both specification paths and specifications. This is a natural consequence of the definition of specification paths. For specifications we can use the identity map and the inverse of the bijection to match path expansions. The parallel relation is, however, not transitive for specification paths. A counterexample would be a path $a$ parallel to $b$ and $b$ parallel to $c$, both with recursion but at different positions in $b$ (ignoring equivalences). We will later show that the parallel relation is transitive for specifications but first we need to introduce a systematic way to capture the bijection between the path expansions.

\section{Matching order}
\todo[inline]{JSE: Make matching order map edges instead of rule indices}
Later when we look to construct bijections with parallel specifications in \ChapterRef{ch:pbijection} the bijections used to pair path expansions will become important. Suppose we have two paths $\alpha$ and $\beta$, in each specification graph of two parallel specifications and they are matchable because there was a bijection between their expansions, $\alpha^+$ and $\beta^+$, such that every pair was matchable. The only difference between the elements in $\alpha^+$ is the last step and the same goes for $\beta^+$. Therefore, we actually have is a bijection between the last steps of paths in $\alpha^+$ and the last steps of paths in $\beta^+$. Suppose the rules with the two tails on the left are
\[
    \textsf{tail}(\alpha) = \mathcal{C} \cong \mathcal{C}^{(1)} \circ_1  \mathcal{C}^{(2)} \circ_1 \dotsm \circ_1 \mathcal{C}^{(s)}
\]
\text{ and }
\[
    \textsf{tail}(\beta) = \mathcal{D} \cong \mathcal{D}^{(1)} \circ_2  \mathcal{D}^{(2)} \circ_2 \dotsm \circ_2 \mathcal{D}^{(r)},
\]
then the bijection can be interpreted as a bijection between $\cset{j \in [s]}{\mathcal{C}^{(j)} \neq \emptyset}$
and $\cset{j \in [r]}{\mathcal{D}^{(j)} \neq \emptyset}$.

By Definition \ref{def:parspec} there is technically nothing stopping us from using different path expansion bijections (if more than one exist) for the same pair if it comes up multiple times but then again, there is also nothing stopping us from using the same one every time and that is precisely what we will do. This way, we can relate pairs of classes, in each specification, that are on the left of a non-equivalence rule to a bijection between the indices of the non-empty classes on the right of said rules. We refer to this mapping as the \emph{matching order} of the pair of classes.

\begin{definition}
Let $\spec{C} = \left(L^{(1)}, O^{(1)}, R^{(1)}, D^{(1)}\right)$ and $\spec{D} = \left(L^{(2)}, O^{(2)}, R^{(2)}, D^{(2)}\right)$ be two parallel specifications with $n$ and $m$ rules respectively. Let
\[
    \left(L^{(1)}_i,L^{(2)}_j\right) \in \set{L^{(1)}_1,L^{(1)}_2,\dotsc,L^{(1)}_n} \times \set{L^{(2)}_1, L^{(2)}_2, \dotsc, L^{(2)}_m}
\]
be a pair of classes that are tails of paths $\alpha$ and $\beta$. Suppose $\alpha$ and $\beta$ are matchable because of an expansion bijection $\phi: \alpha^+ \mapsto \beta^+$. The \emph{matching order}, $\Gamma$, of $L^{(1)}_i$ and $L^{(2)}_j$ is a bijection $\varphi$ such that $\varphi(a) = b$ for $\alpha'\in \alpha^+$ and $\beta'\in \beta^+$ if $\phi(\alpha') = \beta'$, $\textsf{tail}(\alpha') = R^{(1)}_{ia}$ and $\textsf{tail}(\beta')=R^{(2)}_{jb}$.
\end{definition}

The bijections shown in the recursion tree in \FigureRef{fig:para_spec} interpreted with matching order for classes of specifications can be seen in \TableRef{tab:corrmatch}. There are not any recurring pairs in this example but if there were, one would have to choose a fixed bijection and which one does not matter. The benefit of using the matching order is, that it allows us to extend this pairing for arbitrary long paths.

\begin{table}[ht!]
    \centering
    \input{tables/matchingorder}
    \caption{The bijections from \FigureRef{fig:para_spec} interpreted with matching order.}
    \label{tab:corrmatch}
\end{table}

\section{Path matching}
Given two classes $\mathcal{C}$ and $\mathcal{D}$ in the domain of a matching order for two parallel specifications $\spec{C}$ and $\spec{D}$ and an edge $e$ with source $\mathcal{C}$ who's destination is not empty, we define $\xi_{\spec{D}}(e,\mathcal{D})$ as the corresponding edge from $\mathcal{D}$. More formally, let
\[
    \spec{C} = \left(L^{(1)}, O^{(1)}, R^{(1)}, D^{(1)}\right) \text{ and } \spec{D} = \left(L^{(2)}, O^{(2)}, R^{(2)}, D^{(2)}\right)
\]
be two parallel specifications with matching order $\Gamma$. Let $(L_i^{(1)}, L_j^{(2)})$ be a pair of classes in the domain of $\Gamma$. Let $e$ be an edge in $\mathfrak{G}(\spec{C})$ with $\src(e) = L_i^{(1)}$ such that $\dst(e) = R^{(1)}_{ia}\neq\emptyset$. Define $\xi_{\spec{D}}(e,L_j^{(2)}) = e'$ if $\src(e') = L_j^{(2)}$, $\dst(e') = R^{(2)}_{jb}$ and $\Gamma(L_i^{(1)}, L_j^{(2)})(a) = b$. For example, given the specifications and bijections in \FigureRef{fig:para_spec}, we have $\xi_{\spec{D}}(5,F) = 3$ and $\xi_{\spec{C}}(3,B) = 5$.

Define
\[
    \mathscr{P}(\spec{C}) = \cset{p}{p \text{ is a finite rooted path in } \mathfrak{G}(\spec{C}) \text{ and }p = \textsf{rextend}(p)}
\]
for a specification $\spec{C}$. These are the paths that do not have a tail on the left side of an equivalence rule. Given a specification $\spec{D}$, parallel to $\spec{C}$, we can extend the matching of edges to paths in $\mathscr{P}(\spec{C})$ and $\mathscr{P}(\spec{D})$. We will mostly do so sequentially for each edge but special attention must be paid to equivalence rules.

Let $\alpha = a_1a_2 \dotsm a_n$ be a path in $\mathfrak{G}(\spec{C})$ and $\beta$ in $\mathfrak{G}(\spec{D})$ where $\spec{C} \parallel \spec{D}$. Define
\[
    \Psi_{\spec{D}}(\alpha,\beta) = \psi_{\spec{D}}(\textsf{lstrip}(\alpha),\textsf{rextend}(\beta)) 
\]
where
\[
    \psi_{\spec{D}}(\alpha_1\alpha_2\dotsm\alpha_n,\beta) = \begin{cases}
        \beta & \text{ if } n = 0,\\
        \Psi_{\spec{D}}(\alpha_2\alpha_3\dotsm\alpha_n, \beta \oplus \xi_{\spec{D}}(\alpha_1,\textsf{tail}(\beta))) & \text{ otherwise}.
    \end{cases}
\]

\begin{definition}\label{def:pathmatch}
Let $\spec{C}$ and $\spec{D}$ be parallel specifications and $p \in \mathscr{P}(\spec{C})$. The \emph{path matching} of $p$ in $\mathscr{P}(\spec{D})$ is $\gamma_{\spec{D}}(p) = \Psi_{\spec{D}}(p,\varepsilon)$.
\end{definition}

As an example, consider the path $242523$ in $\mathscr{P}(\spec{C})$ in \FigureRef{fig:para_spec}. Its path matching in $\mathscr{P}(\spec{D})$ and the resulting path's path matching in $\mathscr{P}(\spec{C})$ are
\begin{alignat*}{3}
    \gamma_{\spec{D}}(242523) &= \Psi_{\spec{D}}(242523, \varepsilon) &&= \psi_{\spec{D}}(242523, \varepsilon)\\
    &= \Psi_{\spec{D}}(42523,1) &&= \psi_{\spec{D}}(42523,1)\\
    &= \Psi_{\spec{D}}(2523,15) &&= \psi_{\spec{D}}(2523,15)\\
    &= \Psi_{\spec{D}}(523,151) &&= \psi_{\spec{D}}(523,151)\\
    &= \Psi_{\spec{D}}(23,1513) &&= \psi_{\spec{D}}(23,15136)\\
    &= \Psi_{\spec{D}}(3,151368) &&= \psi_{\spec{D}}(3,151368)\\
    &= \Psi_{\spec{D}}(\varepsilon,1513684) &&= \psi_{\spec{D}}(\varepsilon,1513684)\\
    &= 1513684
\end{alignat*}
and
\begin{alignat*}{3}
    \gamma_{\spec{C}}(1513684) &= \Psi_{\spec{C}}(1513684, \varepsilon) &&= \psi_{\spec{C}}(1513684, \varepsilon)\\
    &= \Psi_{\spec{C}}(513684, 2) &&= \psi_{\spec{C}}(513684, 2)\\
    &= \Psi_{\spec{C}}(13684, 24) &&= \psi_{\spec{C}}(13684, 24)\\
    &= \Psi_{\spec{C}}(3684, 242) &&= \psi_{\spec{C}}(3684, 242)\\
    &= \Psi_{\spec{C}}(684, 2425) &&= \psi_{\spec{C}}(84, 2425)\\
    &= \Psi_{\spec{C}}(4, 24252) &&= \psi_{\spec{C}}(4, 24252)\\
    &= \Psi_{\spec{C}}(\varepsilon, 242523) &&= \psi_{\spec{C}}(\varepsilon, 242523)\\
    &= 242523.
\end{alignat*}

The matching order of any class pair will always relate a terminal class to another terminal such that they are isomorphic. Therefore the map $\gamma_{\spec{D}}$ will preserve terminal class tails in the sense that their tails are isomorphic terminal classes. For each nonequivalent step in a path $p$ in the domain of $\gamma_{\spec{D}}$ a nonequivalent step is constructed for $\gamma_{\spec{D}}(p)$. Any other steps added are equivalent steps. Therefore the number of nonequivalent steps is preserved.

\begin{proposition}
The mapping $\gamma_{\spec{D}}: \mathscr{P}(\spec{C}) \mapsto \mathscr{P}(\spec{D})$ is a bijection for parallel specifications $\spec{C}$ and $\spec{D}$ with $\gamma_{\spec{C}} = \gamma_{\spec{D}}^{-1}$.
\end{proposition}
\begin{proof}
Let $(\alpha,\beta) = (\alpha_1\alpha_2\dotsm\alpha_a,\beta_1\beta_2\dotsm\beta_b)\in \mathscr{P}(\spec{C}) \times \mathscr{P}(\spec{D})$ such that
\[
    \alpha = A_1 \oplus \alpha_{i_1} \oplus A_2 \oplus \alpha_{i_2} \oplus \dotsm \oplus A_k \oplus \alpha_{i_k} \oplus A_{k+1}
\]
and
\[
    \beta = B_1 \oplus \beta_{j_1} \oplus B_2 \oplus \beta_{j_2} \oplus \dotsm \oplus B_k \oplus \beta_{j_k} \oplus B_{j+1}
\]
where $\sort(\vartheta(\alpha)) = (\alpha_{i_1},\alpha_{i_2},\dotsm,\alpha_{i_k})$ and $\sort(\vartheta(\beta)) = (\beta_{j_1},\beta_{j_2},\dotsc,\beta_{j_k})$ and $A_i$ and $B_i$ are paths containing only equivalent steps for $i \in [k+1]$. The equivalent steps are uniquely determined by the nonequivalent steps and the map will ignore them for elements in the domain and add them for elements in the codomain.

Suppose that $\gamma_{\spec{D}}(\alpha) = \beta$, then $\xi_{\spec{D}}(\alpha_1\alpha_2\dotsm\alpha_{i_\ell},\src(\beta_{j_\ell})) = \beta_{j_\ell}$ for all $\ell \in [k]$. Therefore the matching order of $(\src(\alpha_{i_\ell}),\src(\beta_{j_\ell}))$ maps $\alpha_{i_\ell}$ to $\beta_{j_\ell}$ (or more pricesly, their indices in their rules) for all $\ell\in[j]$. Since the matching order is a bijection, its inverse will map $\beta_{j_\ell}$ to $\alpha_{i_\ell}$ and we have
\[
    \xi_{\spec{C}}(\beta_1\beta_2\dotsm\beta_{j_\ell},\src(\alpha_{i_\ell})) = \alpha_{i_\ell}
\]
for all $\ell \in [k]$. The map $\gamma_{\spec{C}}$ will remove any equivalent steps from $B$ and add that in the unique manner they can be added in the image, thus $\gamma_{\spec{C}}(\beta) = \alpha$.

Analogously, we have $\gamma_{\spec{D}}(\alpha) = \beta$ assuming $\gamma_{\spec{C}}(\beta) = \alpha$. Since $\gamma_{\spec{C}}(\gamma_{\spec{D}}(\alpha)) = \alpha$ and $\gamma_{\spec{D}}(\gamma_{\spec{C}}(\beta)) = \beta$ the map is a bijection.
\end{proof}

\todo[inline]{JSE: this probably needs some rephrasing after the new matching-order def + add fig - also move to the most appropriate place}
\begin{proposition}
The parallel relation for specifications is transitive.
\end{proposition}
\begin{proof}
Suppose we have specifications $\spec{A}$, $\spec{B}$ and $\spec{C}$ where $\spec{A} \parallel \spec{B}$ with matching order $\Gamma_1$ and $\spec{B} \parallel \spec{C}$ with matching order $\Gamma_2$. We can mimic the paths taken previously from the perspective of $\spec{B}$ (bijection wise) until we reach paths $a = a_1a_2 \dotsm a_k$, $b = b_1b_2 \dotsm b_k$, and $c = c_1c_2 \dotsm c_k$ (all pruned of equivalence steps) that were not expanded further for both $(\spec{A},\spec{B})$ and $(\spec{B},\spec{C})$. If all end in terminal classes then $\mathfrak{p}(a,c)=1$. Otherwise at least one pair has a recursion. Suppose it is $a$ and $b$ and there is an $i$ such that $\dst(a_k)=\src(a_i)$ and $\dst(b_k)=\src(b_i)$. We continue to expand with $\Gamma_1(\src(a_i),\src(b_i)) \circ \Gamma_2(\dst(b_k),\dst(c_k))$ and from here on there will always exist a class $\mathcal{B}$ such that $(\dst(a_{k+1}),\mathcal{B})$ is in the domain of $\Gamma_1$ and $(\mathcal{B}, \dst(c_{k+1}))$ in the domain of $\Gamma_2$. Since there is a finite number of class pairs from $\mathcal{A}$ and $\mathcal{C}$ we will always reach a recursion that matches in both.
\end{proof}



\section{The parallel algorithm}
The parallel algorithm checks if two specifications are parallel and if so, returns the matching order. The graphs are expanded as trees simultaneously\footnote{Not concurrently.} and lineal descendants from the root form a path. At any node in the tree will be the tail of the path taken. A node corresponding to the path $q$ is the parent of the nodes corresponding to the paths in $q^+$, which are called children. Matching orders are stored in a dictionary with class pairs keys. If we can traverse the trees down to matched specification paths, we have parallel specifications.

The algorithm uses dynamic programming to match pairs, remembering both successes and failures. The matching order is done with an iterative backtracking to avoid nesting recursions and fail as soon as possible. If we cannot match the first child to some child in the other node, there is no point trying to match the second child. Whether children 1 and 3 match for given nodes has nothing to do with what children were matched previously so we also remember child matching failures to limit each pair to a single attempt.

The algorithm takes two specifications as input where each specification is represented by a quadruple $(r,o,\phi,n)$ where $r$ is the root class and $o$, $\phi$ and $n$ are maps from classes to constructors, $n$-tuple of non-empty children and the number of non-empty children respectively. The pseudocode can be seen in Algorithm \ref{alg:paraspec} where we use a \texttt{stack} with \texttt{size}, \texttt{pop} and \texttt{push} operations. 

\begin{algorithm}
\input{algs/parallel}
\caption{The parallel algorithm}
\label{alg:paraspec}
\end{algorithm}

Let $n$ and $k$ be the number of classes in the two specifications and $m$ the largest number of children in both specifications. Each pair of classes is never expanded more than once. Each expansion will at most attempt to match each pair of children. By the rule of product there are $nk$ pairs of classes and at most $m^2$ pairs of children. Therefore the worst case time complexity is $\mathcal{O}(nkm^2)$.